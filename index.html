<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5x5 Sudoku</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        :root {
            --bg-color: #f7f3e9;
            --main-color: #5d4037;
            --secondary-color: #a1887f;
            --accent-color: #bcaaa4;
            --solved-color: #d4edda;
            --error-color: #f8d7da;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--main-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            text-align: center;
            width: 100%;
            max-width: 450px;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin: 1.5rem auto;
            border: 3px solid var(--main-color);
            border-radius: 0.5rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .cell {
            width: 100%;
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            background-color: #fff;
            color: var(--main-color);
            border: 1px solid var(--accent-color);
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }

        .cell.fixed {
            background-color: var(--bg-color);
            color: var(--main-color);
            cursor: not-allowed;
            font-weight: 700;
        }

        .cell.highlight {
            background-color: #e0e0e0;
            box-shadow: 0 0 0 2px var(--secondary-color);
        }
        
        /* Region borders for the irregular shapes */
        .cell[data-region-border-top] { border-top: 3px solid var(--main-color) !important; }
        .cell[data-region-border-bottom] { border-bottom: 3px solid var(--main-color) !important; }
        .cell[data-region-border-left] { border-left: 3px solid var(--main-color) !important; }
        .cell[data-region-border-right] { border-right: 3px solid var(--main-color) !important; }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: transform 0.1s, box-shadow 0.1s;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
        }

        .button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }

        .check-button {
            background-color: var(--secondary-color);
            color: white;
        }

        .next-button {
            background-color: var(--main-color);
            color: white;
        }
        
        .hint-button {
            background-color: #6d6d6d;
            color: white;
        }

        .message {
            margin-top: 1.5rem;
            font-weight: bold;
            min-height: 24px;
        }
        
        /* Modal and Number Pad */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .number-pad {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 300px;
        }
        
        .number-pad-button {
            background-color: var(--accent-color);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .number-pad-button:hover {
            background-color: var(--secondary-color);
        }

        .delete-button {
            background-color: #e74c3c;
            color: white;
        }

        .message.success { color: green; }
        .message.error { color: red; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="game-container">
        <h1 class="text-3xl font-bold mb-4 text-center">5x5 Sudoku</h1>

        <div id="grid-container" class="sudoku-grid"></div>

        <div class="control-panel">
            <div class="flex gap-4">
                <button id="check-button" class="button check-button">Check Solution</button>
                <button id="next-button" class="button next-button">Next Puzzle</button>
            </div>
            <button id="hint-button" class="button hint-button">Get Hint (3 left)</button>
        </div>

        <div id="message" class="message"></div>
    </div>
    
    <div id="input-modal" class="modal-overlay hidden">
        <div class="number-pad">
            <button class="number-pad-button" data-value="1">1</button>
            <button class="number-pad-button" data-value="2">2</button>
            <button class="number-pad-button" data-value="3">3</button>
            <button class="number-pad-button" data-value="4">4</button>
            <button class="number-pad-button" data-value="5">5</button>
            <button id="delete-button" class="number-pad-button delete-button">Delete</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_SIZE = 5;
            const gridContainer = document.getElementById('grid-container');
            const checkButton = document.getElementById('check-button');
            const nextButton = document.getElementById('next-button');
            const hintButton = document.getElementById('hint-button');
            const messageEl = document.getElementById('message');
            const inputModal = document.getElementById('input-modal');
            const numberPadButtons = document.querySelectorAll('.number-pad-button');
            const deleteButton = document.getElementById('delete-button');
            
            let board = [];
            let solutionBoard = [];
            let selectedCell = null;
            let hintsRemaining = 3;
            
            // --- REGION DEFINITIONS BASED ON YOUR IMAGE ---
            // Each array element represents a region, and each sub-array is a [row, col] coordinate
            const REGIONS = [
                [[0,0], [1,0], [2,0], [2,1], [3,1]],
                [[0,1], [0,2], [1,1], [1,2], [2,2]],
                [[0,3], [0,4], [1,3], [1,4], [2,3]],
                [[2,4], [3,2], [3,3], [3,4], [4,4]],
                [[3,0], [4,0], [4,1], [4,2], [4,3]]
            ];
            
            // --- CORE SUDOKU GENERATION ALGORITHM ---
            
            function isSafe(grid, row, col, num) {
                // Check row
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[row][x] === num) return false;
                }
                // Check column
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[x][col] === num) return false;
                }
                // Check region
                const regionIndex = getRegionIndex(row, col);
                for (let [r, c] of REGIONS[regionIndex]) {
                    if (grid[r][c] === num) return false;
                }
                return true;
            }

            function getRegionIndex(row, col) {
                for (let i = 0; i < REGIONS.length; i++) {
                    for (let [r, c] of REGIONS[i]) {
                        if (r === row && c === col) return i;
                    }
                }
                return -1; // Should not happen
            }
            
            function solveSudoku(grid) {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (grid[row][col] === 0) {
                            const numbers = [1, 2, 3, 4, 5].sort(() => Math.random() - 0.5);
                            for (let num of numbers) {
                                if (isSafe(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (solveSudoku(grid)) {
                                        return true;
                                    }
                                    grid[row][col] = 0; // Backtrack
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            }
            
            function generateCompleteGrid() {
                const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                solveSudoku(grid);
                return grid;
            }

            function createPuzzle(fullGrid, difficulty) {
                const puzzle = JSON.parse(JSON.stringify(fullGrid));
                let removedCount = 0;
                const cellsToRemove = difficulty * GRID_SIZE;
                
                while (removedCount < cellsToRemove) {
                    const row = Math.floor(Math.random() * GRID_SIZE);
                    const col = Math.floor(Math.random() * GRID_SIZE);
                    
                    if (puzzle[row][col] !== 0) {
                        puzzle[row][col] = 0;
                        removedCount++;
                    }
                }
                return puzzle;
            }
            
            // --- UI RENDERING & INTERACTION ---
            
            function renderGrid(currentBoard) {
                gridContainer.innerHTML = '';
                
                currentBoard.forEach((row, rowIndex) => {
                    row.forEach((value, colIndex) => {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = rowIndex;
                        cell.dataset.col = colIndex;
                        
                        // Add border attributes based on region boundaries
                        const regionIndex = getRegionIndex(rowIndex, colIndex);
                        const isTopBoundary = REGIONS.some(region => region.some(([r,c]) => r === rowIndex-1 && c === colIndex) && !region.some(([r,c]) => r === rowIndex && c === colIndex) && region.includes([rowIndex, colIndex]));
                        
                        const isLeftBoundary = REGIONS.some(region => region.some(([r,c]) => r === rowIndex && c === colIndex-1) && !region.some(([r,c]) => r === rowIndex && c === colIndex) && region.includes([rowIndex, colIndex]));
                        
                        if (rowIndex > 0 && getRegionIndex(rowIndex - 1, colIndex) !== regionIndex) {
                            cell.setAttribute('data-region-border-top', '');
                        }
                        if (colIndex > 0 && getRegionIndex(rowIndex, colIndex - 1) !== regionIndex) {
                            cell.setAttribute('data-region-border-left', '');
                        }
                        if (rowIndex === 0) cell.setAttribute('data-region-border-top', '');
                        if (colIndex === 0) cell.setAttribute('data-region-border-left', '');
                        if (rowIndex === GRID_SIZE - 1) cell.setAttribute('data-region-border-bottom', '');
                        if (colIndex === GRID_SIZE - 1) cell.setAttribute('data-region-border-right', '');
                        
                        if (value !== 0) {
                            cell.textContent = value;
                            cell.classList.add('fixed');
                        } else {
                            cell.textContent = '';
                            cell.addEventListener('click', () => selectCell(cell));
                        }
                        
                        gridContainer.appendChild(cell);
                    });
                });
            }
            
            function selectCell(cell) {
                if (cell.classList.contains('fixed')) return;

                if (selectedCell) {
                    selectedCell.classList.remove('highlight');
                }
                selectedCell = cell;
                selectedCell.classList.add('highlight');
                
                showInputModal();
            }

            function showInputModal() {
                inputModal.classList.remove('hidden');
            }

            function hideInputModal() {
                if(selectedCell) {
                    selectedCell.classList.remove('highlight');
                }
                inputModal.classList.add('hidden');
            }

            function handleNumberInput(value) {
                if (selectedCell) {
                    selectedCell.textContent = value;
                    board[selectedCell.dataset.row][selectedCell.dataset.col] = parseInt(value);
                    hideInputModal();
                }
            }
            
            function handleDelete() {
                if (selectedCell) {
                    selectedCell.textContent = '';
                    board[selectedCell.dataset.row][selectedCell.dataset.col] = 0;
                    hideInputModal();
                }
            }

            function handleHint() {
                if (hintsRemaining <= 0) {
                    messageEl.textContent = "You're out of hints!";
                    messageEl.className = 'message error';
                    return;
                }

                const emptyCells = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (board[r][c] === 0) {
                            emptyCells.push({ row: r, col: c });
                        }
                    }
                }

                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const correctValue = solutionBoard[randomCell.row][randomCell.col];
                    
                    const cellEl = document.querySelector(`.cell[data-row="${randomCell.row}"][data-col="${randomCell.col}"]`);
                    cellEl.textContent = correctValue;
                    cellEl.classList.add('fixed');
                    board[randomCell.row][randomCell.col] = correctValue;
                    
                    hintsRemaining--;
                    hintButton.textContent = `Get Hint (${hintsRemaining} left)`;
                    
                    messageEl.textContent = "A hint has been placed!";
                    messageEl.className = 'message success';
                } else {
                    messageEl.textContent = "The puzzle is already complete!";
                    messageEl.className = 'message error';
                }
            }
            
            // --- GAME LOGIC ---
            
            function checkSolution() {
                let isSolved = true;
                
                // Check if all cells are filled
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (board[r][c] === 0) {
                            isSolved = false;
                            break;
                        }
                    }
                    if (!isSolved) break;
                }

                if (!isSolved) {
                    messageEl.textContent = "Please fill all the numbers first.";
                    messageEl.className = 'message error';
                    return;
                }
                
                // Check if the board matches the solution
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (board[r][c] !== solutionBoard[r][c]) {
                            isSolved = false;
                            break;
                        }
                    }
                    if (!isSolved) break;
                }

                if (isSolved) {
                    messageEl.textContent = "Congratulations! You've solved the puzzle!";
                    messageEl.className = 'message success';
                } else {
                    messageEl.textContent = "Oops! The solution is incorrect. Check your numbers.";
                    messageEl.className = 'message error';
                }
            }
            
            function startNewGame() {
                solutionBoard = generateCompleteGrid();
                board = createPuzzle(solutionBoard, 3); // Difficulty 3 removes more cells
                renderGrid(board);
                messageEl.textContent = "";
                hintsRemaining = 3;
                hintButton.textContent = `Get Hint (${hintsRemaining} left)`;
            }
            
            // --- EVENT LISTENERS ---
            checkButton.addEventListener('click', checkSolution);
            nextButton.addEventListener('click', startNewGame);
            hintButton.addEventListener('click', handleHint);
            
            numberPadButtons.forEach(button => {
                button.addEventListener('click', () => handleNumberInput(button.dataset.value));
            });
            deleteButton.addEventListener('click', handleDelete);
            
            // Close modal if user clicks outside of it
            inputModal.addEventListener('click', (e) => {
                if(e.target === inputModal) {
                    hideInputModal();
                }
            });
            
            // Start the game on initial load
            startNewGame();
        });
    </script>
</body>
</html>
